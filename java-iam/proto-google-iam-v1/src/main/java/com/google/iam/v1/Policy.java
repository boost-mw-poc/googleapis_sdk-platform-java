/*
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/iam/v1/policy.proto

// Protobuf Java Version: 3.25.5
package com.google.iam.v1;

/**
 *
 *
 * <pre>
 * An Identity and Access Management (IAM) policy, which specifies access
 * controls for Google Cloud resources.
 *
 *
 * A `Policy` is a collection of `bindings`. A `binding` binds one or more
 * `members`, or principals, to a single `role`. Principals can be user
 * accounts, service accounts, Google groups, and domains (such as G Suite). A
 * `role` is a named list of permissions; each `role` can be an IAM predefined
 * role or a user-created custom role.
 *
 * For some types of Google Cloud resources, a `binding` can also specify a
 * `condition`, which is a logical expression that allows access to a resource
 * only if the expression evaluates to `true`. A condition can add constraints
 * based on attributes of the request, the resource, or both. To learn which
 * resources support conditions in their IAM policies, see the
 * [IAM
 * documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
 *
 * **JSON example:**
 *
 * ```
 *     {
 *       "bindings": [
 *         {
 *           "role": "roles/resourcemanager.organizationAdmin",
 *           "members": [
 *             "user:mike&#64;example.com",
 *             "group:admins&#64;example.com",
 *             "domain:google.com",
 *             "serviceAccount:my-project-id&#64;appspot.gserviceaccount.com"
 *           ]
 *         },
 *         {
 *           "role": "roles/resourcemanager.organizationViewer",
 *           "members": [
 *             "user:eve&#64;example.com"
 *           ],
 *           "condition": {
 *             "title": "expirable access",
 *             "description": "Does not grant access after Sep 2020",
 *             "expression": "request.time &lt;
 *             timestamp('2020-10-01T00:00:00.000Z')",
 *           }
 *         }
 *       ],
 *       "etag": "BwWWja0YfJA=",
 *       "version": 3
 *     }
 * ```
 *
 * **YAML example:**
 *
 * ```
 *     bindings:
 *     - members:
 *       - user:mike&#64;example.com
 *       - group:admins&#64;example.com
 *       - domain:google.com
 *       - serviceAccount:my-project-id&#64;appspot.gserviceaccount.com
 *       role: roles/resourcemanager.organizationAdmin
 *     - members:
 *       - user:eve&#64;example.com
 *       role: roles/resourcemanager.organizationViewer
 *       condition:
 *         title: expirable access
 *         description: Does not grant access after Sep 2020
 *         expression: request.time &lt; timestamp('2020-10-01T00:00:00.000Z')
 *     etag: BwWWja0YfJA=
 *     version: 3
 * ```
 *
 * For a description of IAM and its features, see the
 * [IAM documentation](https://cloud.google.com/iam/docs/).
 * </pre>
 *
 * Protobuf type {@code google.iam.v1.Policy}
 */
public final class Policy extends com.google.protobuf.GeneratedMessageLite<Policy, Policy.Builder>
    implements
    // @@protoc_insertion_point(message_implements:google.iam.v1.Policy)
    PolicyOrBuilder {
  private Policy() {
    bindings_ = emptyProtobufList();
    auditConfigs_ = emptyProtobufList();
    etag_ = com.google.protobuf.ByteString.EMPTY;
  }

  public static final int VERSION_FIELD_NUMBER = 1;
  private int version_;
  /**
   *
   *
   * <pre>
   * Specifies the format of the policy.
   *
   * Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
   * are rejected.
   *
   * Any operation that affects conditional role bindings must specify version
   * `3`. This requirement applies to the following operations:
   *
   * * Getting a policy that includes a conditional role binding
   * * Adding a conditional role binding to a policy
   * * Changing a conditional role binding in a policy
   * * Removing any role binding, with or without a condition, from a policy
   *   that includes conditions
   *
   * **Important:** If you use IAM Conditions, you must include the `etag` field
   * whenever you call `setIamPolicy`. If you omit this field, then IAM allows
   * you to overwrite a version `3` policy with a version `1` policy, and all of
   * the conditions in the version `3` policy are lost.
   *
   * If a policy does not include any conditions, operations on that policy may
   * specify any valid version or leave the field unset.
   *
   * To learn which resources support conditions in their IAM policies, see the
   * [IAM
   * documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
   * </pre>
   *
   * <code>int32 version = 1;</code>
   *
   * @return The version.
   */
  @java.lang.Override
  public int getVersion() {
    return version_;
  }
  /**
   *
   *
   * <pre>
   * Specifies the format of the policy.
   *
   * Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
   * are rejected.
   *
   * Any operation that affects conditional role bindings must specify version
   * `3`. This requirement applies to the following operations:
   *
   * * Getting a policy that includes a conditional role binding
   * * Adding a conditional role binding to a policy
   * * Changing a conditional role binding in a policy
   * * Removing any role binding, with or without a condition, from a policy
   *   that includes conditions
   *
   * **Important:** If you use IAM Conditions, you must include the `etag` field
   * whenever you call `setIamPolicy`. If you omit this field, then IAM allows
   * you to overwrite a version `3` policy with a version `1` policy, and all of
   * the conditions in the version `3` policy are lost.
   *
   * If a policy does not include any conditions, operations on that policy may
   * specify any valid version or leave the field unset.
   *
   * To learn which resources support conditions in their IAM policies, see the
   * [IAM
   * documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
   * </pre>
   *
   * <code>int32 version = 1;</code>
   *
   * @param value The version to set.
   */
  private void setVersion(int value) {

    version_ = value;
  }
  /**
   *
   *
   * <pre>
   * Specifies the format of the policy.
   *
   * Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
   * are rejected.
   *
   * Any operation that affects conditional role bindings must specify version
   * `3`. This requirement applies to the following operations:
   *
   * * Getting a policy that includes a conditional role binding
   * * Adding a conditional role binding to a policy
   * * Changing a conditional role binding in a policy
   * * Removing any role binding, with or without a condition, from a policy
   *   that includes conditions
   *
   * **Important:** If you use IAM Conditions, you must include the `etag` field
   * whenever you call `setIamPolicy`. If you omit this field, then IAM allows
   * you to overwrite a version `3` policy with a version `1` policy, and all of
   * the conditions in the version `3` policy are lost.
   *
   * If a policy does not include any conditions, operations on that policy may
   * specify any valid version or leave the field unset.
   *
   * To learn which resources support conditions in their IAM policies, see the
   * [IAM
   * documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
   * </pre>
   *
   * <code>int32 version = 1;</code>
   */
  private void clearVersion() {

    version_ = 0;
  }

  public static final int BINDINGS_FIELD_NUMBER = 4;
  private com.google.protobuf.Internal.ProtobufList<com.google.iam.v1.Binding> bindings_;
  /**
   *
   *
   * <pre>
   * Associates a list of `members`, or principals, with a `role`. Optionally,
   * may specify a `condition` that determines how and when the `bindings` are
   * applied. Each of the `bindings` must contain at least one principal.
   *
   * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
   * of these principals can be Google groups. Each occurrence of a principal
   * counts towards these limits. For example, if the `bindings` grant 50
   * different roles to `user:alice&#64;example.com`, and not to any other
   * principal, then you can add another 1,450 principals to the `bindings` in
   * the `Policy`.
   * </pre>
   *
   * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
   */
  @java.lang.Override
  public java.util.List<com.google.iam.v1.Binding> getBindingsList() {
    return bindings_;
  }
  /**
   *
   *
   * <pre>
   * Associates a list of `members`, or principals, with a `role`. Optionally,
   * may specify a `condition` that determines how and when the `bindings` are
   * applied. Each of the `bindings` must contain at least one principal.
   *
   * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
   * of these principals can be Google groups. Each occurrence of a principal
   * counts towards these limits. For example, if the `bindings` grant 50
   * different roles to `user:alice&#64;example.com`, and not to any other
   * principal, then you can add another 1,450 principals to the `bindings` in
   * the `Policy`.
   * </pre>
   *
   * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
   */
  public java.util.List<? extends com.google.iam.v1.BindingOrBuilder> getBindingsOrBuilderList() {
    return bindings_;
  }
  /**
   *
   *
   * <pre>
   * Associates a list of `members`, or principals, with a `role`. Optionally,
   * may specify a `condition` that determines how and when the `bindings` are
   * applied. Each of the `bindings` must contain at least one principal.
   *
   * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
   * of these principals can be Google groups. Each occurrence of a principal
   * counts towards these limits. For example, if the `bindings` grant 50
   * different roles to `user:alice&#64;example.com`, and not to any other
   * principal, then you can add another 1,450 principals to the `bindings` in
   * the `Policy`.
   * </pre>
   *
   * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
   */
  @java.lang.Override
  public int getBindingsCount() {
    return bindings_.size();
  }
  /**
   *
   *
   * <pre>
   * Associates a list of `members`, or principals, with a `role`. Optionally,
   * may specify a `condition` that determines how and when the `bindings` are
   * applied. Each of the `bindings` must contain at least one principal.
   *
   * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
   * of these principals can be Google groups. Each occurrence of a principal
   * counts towards these limits. For example, if the `bindings` grant 50
   * different roles to `user:alice&#64;example.com`, and not to any other
   * principal, then you can add another 1,450 principals to the `bindings` in
   * the `Policy`.
   * </pre>
   *
   * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
   */
  @java.lang.Override
  public com.google.iam.v1.Binding getBindings(int index) {
    return bindings_.get(index);
  }
  /**
   *
   *
   * <pre>
   * Associates a list of `members`, or principals, with a `role`. Optionally,
   * may specify a `condition` that determines how and when the `bindings` are
   * applied. Each of the `bindings` must contain at least one principal.
   *
   * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
   * of these principals can be Google groups. Each occurrence of a principal
   * counts towards these limits. For example, if the `bindings` grant 50
   * different roles to `user:alice&#64;example.com`, and not to any other
   * principal, then you can add another 1,450 principals to the `bindings` in
   * the `Policy`.
   * </pre>
   *
   * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
   */
  public com.google.iam.v1.BindingOrBuilder getBindingsOrBuilder(int index) {
    return bindings_.get(index);
  }

  private void ensureBindingsIsMutable() {
    com.google.protobuf.Internal.ProtobufList<com.google.iam.v1.Binding> tmp = bindings_;
    if (!tmp.isModifiable()) {
      bindings_ = com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
    }
  }

  /**
   *
   *
   * <pre>
   * Associates a list of `members`, or principals, with a `role`. Optionally,
   * may specify a `condition` that determines how and when the `bindings` are
   * applied. Each of the `bindings` must contain at least one principal.
   *
   * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
   * of these principals can be Google groups. Each occurrence of a principal
   * counts towards these limits. For example, if the `bindings` grant 50
   * different roles to `user:alice&#64;example.com`, and not to any other
   * principal, then you can add another 1,450 principals to the `bindings` in
   * the `Policy`.
   * </pre>
   *
   * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
   */
  private void setBindings(int index, com.google.iam.v1.Binding value) {
    value.getClass();
    ensureBindingsIsMutable();
    bindings_.set(index, value);
  }
  /**
   *
   *
   * <pre>
   * Associates a list of `members`, or principals, with a `role`. Optionally,
   * may specify a `condition` that determines how and when the `bindings` are
   * applied. Each of the `bindings` must contain at least one principal.
   *
   * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
   * of these principals can be Google groups. Each occurrence of a principal
   * counts towards these limits. For example, if the `bindings` grant 50
   * different roles to `user:alice&#64;example.com`, and not to any other
   * principal, then you can add another 1,450 principals to the `bindings` in
   * the `Policy`.
   * </pre>
   *
   * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
   */
  private void addBindings(com.google.iam.v1.Binding value) {
    value.getClass();
    ensureBindingsIsMutable();
    bindings_.add(value);
  }
  /**
   *
   *
   * <pre>
   * Associates a list of `members`, or principals, with a `role`. Optionally,
   * may specify a `condition` that determines how and when the `bindings` are
   * applied. Each of the `bindings` must contain at least one principal.
   *
   * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
   * of these principals can be Google groups. Each occurrence of a principal
   * counts towards these limits. For example, if the `bindings` grant 50
   * different roles to `user:alice&#64;example.com`, and not to any other
   * principal, then you can add another 1,450 principals to the `bindings` in
   * the `Policy`.
   * </pre>
   *
   * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
   */
  private void addBindings(int index, com.google.iam.v1.Binding value) {
    value.getClass();
    ensureBindingsIsMutable();
    bindings_.add(index, value);
  }
  /**
   *
   *
   * <pre>
   * Associates a list of `members`, or principals, with a `role`. Optionally,
   * may specify a `condition` that determines how and when the `bindings` are
   * applied. Each of the `bindings` must contain at least one principal.
   *
   * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
   * of these principals can be Google groups. Each occurrence of a principal
   * counts towards these limits. For example, if the `bindings` grant 50
   * different roles to `user:alice&#64;example.com`, and not to any other
   * principal, then you can add another 1,450 principals to the `bindings` in
   * the `Policy`.
   * </pre>
   *
   * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
   */
  private void addAllBindings(java.lang.Iterable<? extends com.google.iam.v1.Binding> values) {
    ensureBindingsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(values, bindings_);
  }
  /**
   *
   *
   * <pre>
   * Associates a list of `members`, or principals, with a `role`. Optionally,
   * may specify a `condition` that determines how and when the `bindings` are
   * applied. Each of the `bindings` must contain at least one principal.
   *
   * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
   * of these principals can be Google groups. Each occurrence of a principal
   * counts towards these limits. For example, if the `bindings` grant 50
   * different roles to `user:alice&#64;example.com`, and not to any other
   * principal, then you can add another 1,450 principals to the `bindings` in
   * the `Policy`.
   * </pre>
   *
   * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
   */
  private void clearBindings() {
    bindings_ = emptyProtobufList();
  }
  /**
   *
   *
   * <pre>
   * Associates a list of `members`, or principals, with a `role`. Optionally,
   * may specify a `condition` that determines how and when the `bindings` are
   * applied. Each of the `bindings` must contain at least one principal.
   *
   * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
   * of these principals can be Google groups. Each occurrence of a principal
   * counts towards these limits. For example, if the `bindings` grant 50
   * different roles to `user:alice&#64;example.com`, and not to any other
   * principal, then you can add another 1,450 principals to the `bindings` in
   * the `Policy`.
   * </pre>
   *
   * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
   */
  private void removeBindings(int index) {
    ensureBindingsIsMutable();
    bindings_.remove(index);
  }

  public static final int AUDIT_CONFIGS_FIELD_NUMBER = 6;
  private com.google.protobuf.Internal.ProtobufList<com.google.iam.v1.AuditConfig> auditConfigs_;
  /**
   *
   *
   * <pre>
   * Specifies cloud audit logging configuration for this policy.
   * </pre>
   *
   * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
   */
  @java.lang.Override
  public java.util.List<com.google.iam.v1.AuditConfig> getAuditConfigsList() {
    return auditConfigs_;
  }
  /**
   *
   *
   * <pre>
   * Specifies cloud audit logging configuration for this policy.
   * </pre>
   *
   * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
   */
  public java.util.List<? extends com.google.iam.v1.AuditConfigOrBuilder>
      getAuditConfigsOrBuilderList() {
    return auditConfigs_;
  }
  /**
   *
   *
   * <pre>
   * Specifies cloud audit logging configuration for this policy.
   * </pre>
   *
   * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
   */
  @java.lang.Override
  public int getAuditConfigsCount() {
    return auditConfigs_.size();
  }
  /**
   *
   *
   * <pre>
   * Specifies cloud audit logging configuration for this policy.
   * </pre>
   *
   * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
   */
  @java.lang.Override
  public com.google.iam.v1.AuditConfig getAuditConfigs(int index) {
    return auditConfigs_.get(index);
  }
  /**
   *
   *
   * <pre>
   * Specifies cloud audit logging configuration for this policy.
   * </pre>
   *
   * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
   */
  public com.google.iam.v1.AuditConfigOrBuilder getAuditConfigsOrBuilder(int index) {
    return auditConfigs_.get(index);
  }

  private void ensureAuditConfigsIsMutable() {
    com.google.protobuf.Internal.ProtobufList<com.google.iam.v1.AuditConfig> tmp = auditConfigs_;
    if (!tmp.isModifiable()) {
      auditConfigs_ = com.google.protobuf.GeneratedMessageLite.mutableCopy(tmp);
    }
  }

  /**
   *
   *
   * <pre>
   * Specifies cloud audit logging configuration for this policy.
   * </pre>
   *
   * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
   */
  private void setAuditConfigs(int index, com.google.iam.v1.AuditConfig value) {
    value.getClass();
    ensureAuditConfigsIsMutable();
    auditConfigs_.set(index, value);
  }
  /**
   *
   *
   * <pre>
   * Specifies cloud audit logging configuration for this policy.
   * </pre>
   *
   * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
   */
  private void addAuditConfigs(com.google.iam.v1.AuditConfig value) {
    value.getClass();
    ensureAuditConfigsIsMutable();
    auditConfigs_.add(value);
  }
  /**
   *
   *
   * <pre>
   * Specifies cloud audit logging configuration for this policy.
   * </pre>
   *
   * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
   */
  private void addAuditConfigs(int index, com.google.iam.v1.AuditConfig value) {
    value.getClass();
    ensureAuditConfigsIsMutable();
    auditConfigs_.add(index, value);
  }
  /**
   *
   *
   * <pre>
   * Specifies cloud audit logging configuration for this policy.
   * </pre>
   *
   * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
   */
  private void addAllAuditConfigs(
      java.lang.Iterable<? extends com.google.iam.v1.AuditConfig> values) {
    ensureAuditConfigsIsMutable();
    com.google.protobuf.AbstractMessageLite.addAll(values, auditConfigs_);
  }
  /**
   *
   *
   * <pre>
   * Specifies cloud audit logging configuration for this policy.
   * </pre>
   *
   * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
   */
  private void clearAuditConfigs() {
    auditConfigs_ = emptyProtobufList();
  }
  /**
   *
   *
   * <pre>
   * Specifies cloud audit logging configuration for this policy.
   * </pre>
   *
   * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
   */
  private void removeAuditConfigs(int index) {
    ensureAuditConfigsIsMutable();
    auditConfigs_.remove(index);
  }

  public static final int ETAG_FIELD_NUMBER = 3;
  private com.google.protobuf.ByteString etag_;
  /**
   *
   *
   * <pre>
   * `etag` is used for optimistic concurrency control as a way to help
   * prevent simultaneous updates of a policy from overwriting each other.
   * It is strongly suggested that systems make use of the `etag` in the
   * read-modify-write cycle to perform policy updates in order to avoid race
   * conditions: An `etag` is returned in the response to `getIamPolicy`, and
   * systems are expected to put that etag in the request to `setIamPolicy` to
   * ensure that their change will be applied to the same version of the policy.
   *
   * **Important:** If you use IAM Conditions, you must include the `etag` field
   * whenever you call `setIamPolicy`. If you omit this field, then IAM allows
   * you to overwrite a version `3` policy with a version `1` policy, and all of
   * the conditions in the version `3` policy are lost.
   * </pre>
   *
   * <code>bytes etag = 3;</code>
   *
   * @return The etag.
   */
  @java.lang.Override
  public com.google.protobuf.ByteString getEtag() {
    return etag_;
  }
  /**
   *
   *
   * <pre>
   * `etag` is used for optimistic concurrency control as a way to help
   * prevent simultaneous updates of a policy from overwriting each other.
   * It is strongly suggested that systems make use of the `etag` in the
   * read-modify-write cycle to perform policy updates in order to avoid race
   * conditions: An `etag` is returned in the response to `getIamPolicy`, and
   * systems are expected to put that etag in the request to `setIamPolicy` to
   * ensure that their change will be applied to the same version of the policy.
   *
   * **Important:** If you use IAM Conditions, you must include the `etag` field
   * whenever you call `setIamPolicy`. If you omit this field, then IAM allows
   * you to overwrite a version `3` policy with a version `1` policy, and all of
   * the conditions in the version `3` policy are lost.
   * </pre>
   *
   * <code>bytes etag = 3;</code>
   *
   * @param value The etag to set.
   */
  private void setEtag(com.google.protobuf.ByteString value) {
    java.lang.Class<?> valueClass = value.getClass();

    etag_ = value;
  }
  /**
   *
   *
   * <pre>
   * `etag` is used for optimistic concurrency control as a way to help
   * prevent simultaneous updates of a policy from overwriting each other.
   * It is strongly suggested that systems make use of the `etag` in the
   * read-modify-write cycle to perform policy updates in order to avoid race
   * conditions: An `etag` is returned in the response to `getIamPolicy`, and
   * systems are expected to put that etag in the request to `setIamPolicy` to
   * ensure that their change will be applied to the same version of the policy.
   *
   * **Important:** If you use IAM Conditions, you must include the `etag` field
   * whenever you call `setIamPolicy`. If you omit this field, then IAM allows
   * you to overwrite a version `3` policy with a version `1` policy, and all of
   * the conditions in the version `3` policy are lost.
   * </pre>
   *
   * <code>bytes etag = 3;</code>
   */
  private void clearEtag() {

    etag_ = getDefaultInstance().getEtag();
  }

  public static com.google.iam.v1.Policy parseFrom(java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(DEFAULT_INSTANCE, data);
  }

  public static com.google.iam.v1.Policy parseFrom(
      java.nio.ByteBuffer data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }

  public static com.google.iam.v1.Policy parseFrom(com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(DEFAULT_INSTANCE, data);
  }

  public static com.google.iam.v1.Policy parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }

  public static com.google.iam.v1.Policy parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(DEFAULT_INSTANCE, data);
  }

  public static com.google.iam.v1.Policy parseFrom(
      byte[] data, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, data, extensionRegistry);
  }

  public static com.google.iam.v1.Policy parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(DEFAULT_INSTANCE, input);
  }

  public static com.google.iam.v1.Policy parseFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static com.google.iam.v1.Policy parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input);
  }

  public static com.google.iam.v1.Policy parseDelimitedFrom(
      java.io.InputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return parseDelimitedFrom(DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static com.google.iam.v1.Policy parseFrom(com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(DEFAULT_INSTANCE, input);
  }

  public static com.google.iam.v1.Policy parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageLite.parseFrom(
        DEFAULT_INSTANCE, input, extensionRegistry);
  }

  public static Builder newBuilder() {
    return (Builder) DEFAULT_INSTANCE.createBuilder();
  }

  public static Builder newBuilder(com.google.iam.v1.Policy prototype) {
    return DEFAULT_INSTANCE.createBuilder(prototype);
  }

  /**
   *
   *
   * <pre>
   * An Identity and Access Management (IAM) policy, which specifies access
   * controls for Google Cloud resources.
   *
   *
   * A `Policy` is a collection of `bindings`. A `binding` binds one or more
   * `members`, or principals, to a single `role`. Principals can be user
   * accounts, service accounts, Google groups, and domains (such as G Suite). A
   * `role` is a named list of permissions; each `role` can be an IAM predefined
   * role or a user-created custom role.
   *
   * For some types of Google Cloud resources, a `binding` can also specify a
   * `condition`, which is a logical expression that allows access to a resource
   * only if the expression evaluates to `true`. A condition can add constraints
   * based on attributes of the request, the resource, or both. To learn which
   * resources support conditions in their IAM policies, see the
   * [IAM
   * documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
   *
   * **JSON example:**
   *
   * ```
   *     {
   *       "bindings": [
   *         {
   *           "role": "roles/resourcemanager.organizationAdmin",
   *           "members": [
   *             "user:mike&#64;example.com",
   *             "group:admins&#64;example.com",
   *             "domain:google.com",
   *             "serviceAccount:my-project-id&#64;appspot.gserviceaccount.com"
   *           ]
   *         },
   *         {
   *           "role": "roles/resourcemanager.organizationViewer",
   *           "members": [
   *             "user:eve&#64;example.com"
   *           ],
   *           "condition": {
   *             "title": "expirable access",
   *             "description": "Does not grant access after Sep 2020",
   *             "expression": "request.time &lt;
   *             timestamp('2020-10-01T00:00:00.000Z')",
   *           }
   *         }
   *       ],
   *       "etag": "BwWWja0YfJA=",
   *       "version": 3
   *     }
   * ```
   *
   * **YAML example:**
   *
   * ```
   *     bindings:
   *     - members:
   *       - user:mike&#64;example.com
   *       - group:admins&#64;example.com
   *       - domain:google.com
   *       - serviceAccount:my-project-id&#64;appspot.gserviceaccount.com
   *       role: roles/resourcemanager.organizationAdmin
   *     - members:
   *       - user:eve&#64;example.com
   *       role: roles/resourcemanager.organizationViewer
   *       condition:
   *         title: expirable access
   *         description: Does not grant access after Sep 2020
   *         expression: request.time &lt; timestamp('2020-10-01T00:00:00.000Z')
   *     etag: BwWWja0YfJA=
   *     version: 3
   * ```
   *
   * For a description of IAM and its features, see the
   * [IAM documentation](https://cloud.google.com/iam/docs/).
   * </pre>
   *
   * Protobuf type {@code google.iam.v1.Policy}
   */
  public static final class Builder
      extends com.google.protobuf.GeneratedMessageLite.Builder<com.google.iam.v1.Policy, Builder>
      implements
      // @@protoc_insertion_point(builder_implements:google.iam.v1.Policy)
      com.google.iam.v1.PolicyOrBuilder {
    // Construct using com.google.iam.v1.Policy.newBuilder()
    private Builder() {
      super(DEFAULT_INSTANCE);
    }

    /**
     *
     *
     * <pre>
     * Specifies the format of the policy.
     *
     * Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
     * are rejected.
     *
     * Any operation that affects conditional role bindings must specify version
     * `3`. This requirement applies to the following operations:
     *
     * * Getting a policy that includes a conditional role binding
     * * Adding a conditional role binding to a policy
     * * Changing a conditional role binding in a policy
     * * Removing any role binding, with or without a condition, from a policy
     *   that includes conditions
     *
     * **Important:** If you use IAM Conditions, you must include the `etag` field
     * whenever you call `setIamPolicy`. If you omit this field, then IAM allows
     * you to overwrite a version `3` policy with a version `1` policy, and all of
     * the conditions in the version `3` policy are lost.
     *
     * If a policy does not include any conditions, operations on that policy may
     * specify any valid version or leave the field unset.
     *
     * To learn which resources support conditions in their IAM policies, see the
     * [IAM
     * documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
     * </pre>
     *
     * <code>int32 version = 1;</code>
     *
     * @return The version.
     */
    @java.lang.Override
    public int getVersion() {
      return instance.getVersion();
    }
    /**
     *
     *
     * <pre>
     * Specifies the format of the policy.
     *
     * Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
     * are rejected.
     *
     * Any operation that affects conditional role bindings must specify version
     * `3`. This requirement applies to the following operations:
     *
     * * Getting a policy that includes a conditional role binding
     * * Adding a conditional role binding to a policy
     * * Changing a conditional role binding in a policy
     * * Removing any role binding, with or without a condition, from a policy
     *   that includes conditions
     *
     * **Important:** If you use IAM Conditions, you must include the `etag` field
     * whenever you call `setIamPolicy`. If you omit this field, then IAM allows
     * you to overwrite a version `3` policy with a version `1` policy, and all of
     * the conditions in the version `3` policy are lost.
     *
     * If a policy does not include any conditions, operations on that policy may
     * specify any valid version or leave the field unset.
     *
     * To learn which resources support conditions in their IAM policies, see the
     * [IAM
     * documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
     * </pre>
     *
     * <code>int32 version = 1;</code>
     *
     * @param value The version to set.
     * @return This builder for chaining.
     */
    public Builder setVersion(int value) {
      copyOnWrite();
      instance.setVersion(value);
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies the format of the policy.
     *
     * Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
     * are rejected.
     *
     * Any operation that affects conditional role bindings must specify version
     * `3`. This requirement applies to the following operations:
     *
     * * Getting a policy that includes a conditional role binding
     * * Adding a conditional role binding to a policy
     * * Changing a conditional role binding in a policy
     * * Removing any role binding, with or without a condition, from a policy
     *   that includes conditions
     *
     * **Important:** If you use IAM Conditions, you must include the `etag` field
     * whenever you call `setIamPolicy`. If you omit this field, then IAM allows
     * you to overwrite a version `3` policy with a version `1` policy, and all of
     * the conditions in the version `3` policy are lost.
     *
     * If a policy does not include any conditions, operations on that policy may
     * specify any valid version or leave the field unset.
     *
     * To learn which resources support conditions in their IAM policies, see the
     * [IAM
     * documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
     * </pre>
     *
     * <code>int32 version = 1;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearVersion() {
      copyOnWrite();
      instance.clearVersion();
      return this;
    }

    /**
     *
     *
     * <pre>
     * Associates a list of `members`, or principals, with a `role`. Optionally,
     * may specify a `condition` that determines how and when the `bindings` are
     * applied. Each of the `bindings` must contain at least one principal.
     *
     * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
     * of these principals can be Google groups. Each occurrence of a principal
     * counts towards these limits. For example, if the `bindings` grant 50
     * different roles to `user:alice&#64;example.com`, and not to any other
     * principal, then you can add another 1,450 principals to the `bindings` in
     * the `Policy`.
     * </pre>
     *
     * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.iam.v1.Binding> getBindingsList() {
      return java.util.Collections.unmodifiableList(instance.getBindingsList());
    }
    /**
     *
     *
     * <pre>
     * Associates a list of `members`, or principals, with a `role`. Optionally,
     * may specify a `condition` that determines how and when the `bindings` are
     * applied. Each of the `bindings` must contain at least one principal.
     *
     * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
     * of these principals can be Google groups. Each occurrence of a principal
     * counts towards these limits. For example, if the `bindings` grant 50
     * different roles to `user:alice&#64;example.com`, and not to any other
     * principal, then you can add another 1,450 principals to the `bindings` in
     * the `Policy`.
     * </pre>
     *
     * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
     */
    @java.lang.Override
    public int getBindingsCount() {
      return instance.getBindingsCount();
    }
    /**
     *
     *
     * <pre>
     * Associates a list of `members`, or principals, with a `role`. Optionally,
     * may specify a `condition` that determines how and when the `bindings` are
     * applied. Each of the `bindings` must contain at least one principal.
     *
     * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
     * of these principals can be Google groups. Each occurrence of a principal
     * counts towards these limits. For example, if the `bindings` grant 50
     * different roles to `user:alice&#64;example.com`, and not to any other
     * principal, then you can add another 1,450 principals to the `bindings` in
     * the `Policy`.
     * </pre>
     *
     * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
     */

    @java.lang.Override
    public com.google.iam.v1.Binding getBindings(int index) {
      return instance.getBindings(index);
    }
    /**
     *
     *
     * <pre>
     * Associates a list of `members`, or principals, with a `role`. Optionally,
     * may specify a `condition` that determines how and when the `bindings` are
     * applied. Each of the `bindings` must contain at least one principal.
     *
     * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
     * of these principals can be Google groups. Each occurrence of a principal
     * counts towards these limits. For example, if the `bindings` grant 50
     * different roles to `user:alice&#64;example.com`, and not to any other
     * principal, then you can add another 1,450 principals to the `bindings` in
     * the `Policy`.
     * </pre>
     *
     * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
     */
    public Builder setBindings(int index, com.google.iam.v1.Binding value) {
      copyOnWrite();
      instance.setBindings(index, value);
      return this;
    }
    /**
     *
     *
     * <pre>
     * Associates a list of `members`, or principals, with a `role`. Optionally,
     * may specify a `condition` that determines how and when the `bindings` are
     * applied. Each of the `bindings` must contain at least one principal.
     *
     * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
     * of these principals can be Google groups. Each occurrence of a principal
     * counts towards these limits. For example, if the `bindings` grant 50
     * different roles to `user:alice&#64;example.com`, and not to any other
     * principal, then you can add another 1,450 principals to the `bindings` in
     * the `Policy`.
     * </pre>
     *
     * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
     */
    public Builder setBindings(int index, com.google.iam.v1.Binding.Builder builderForValue) {
      copyOnWrite();
      instance.setBindings(index, builderForValue.build());
      return this;
    }
    /**
     *
     *
     * <pre>
     * Associates a list of `members`, or principals, with a `role`. Optionally,
     * may specify a `condition` that determines how and when the `bindings` are
     * applied. Each of the `bindings` must contain at least one principal.
     *
     * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
     * of these principals can be Google groups. Each occurrence of a principal
     * counts towards these limits. For example, if the `bindings` grant 50
     * different roles to `user:alice&#64;example.com`, and not to any other
     * principal, then you can add another 1,450 principals to the `bindings` in
     * the `Policy`.
     * </pre>
     *
     * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
     */
    public Builder addBindings(com.google.iam.v1.Binding value) {
      copyOnWrite();
      instance.addBindings(value);
      return this;
    }
    /**
     *
     *
     * <pre>
     * Associates a list of `members`, or principals, with a `role`. Optionally,
     * may specify a `condition` that determines how and when the `bindings` are
     * applied. Each of the `bindings` must contain at least one principal.
     *
     * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
     * of these principals can be Google groups. Each occurrence of a principal
     * counts towards these limits. For example, if the `bindings` grant 50
     * different roles to `user:alice&#64;example.com`, and not to any other
     * principal, then you can add another 1,450 principals to the `bindings` in
     * the `Policy`.
     * </pre>
     *
     * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
     */
    public Builder addBindings(int index, com.google.iam.v1.Binding value) {
      copyOnWrite();
      instance.addBindings(index, value);
      return this;
    }
    /**
     *
     *
     * <pre>
     * Associates a list of `members`, or principals, with a `role`. Optionally,
     * may specify a `condition` that determines how and when the `bindings` are
     * applied. Each of the `bindings` must contain at least one principal.
     *
     * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
     * of these principals can be Google groups. Each occurrence of a principal
     * counts towards these limits. For example, if the `bindings` grant 50
     * different roles to `user:alice&#64;example.com`, and not to any other
     * principal, then you can add another 1,450 principals to the `bindings` in
     * the `Policy`.
     * </pre>
     *
     * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
     */
    public Builder addBindings(com.google.iam.v1.Binding.Builder builderForValue) {
      copyOnWrite();
      instance.addBindings(builderForValue.build());
      return this;
    }
    /**
     *
     *
     * <pre>
     * Associates a list of `members`, or principals, with a `role`. Optionally,
     * may specify a `condition` that determines how and when the `bindings` are
     * applied. Each of the `bindings` must contain at least one principal.
     *
     * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
     * of these principals can be Google groups. Each occurrence of a principal
     * counts towards these limits. For example, if the `bindings` grant 50
     * different roles to `user:alice&#64;example.com`, and not to any other
     * principal, then you can add another 1,450 principals to the `bindings` in
     * the `Policy`.
     * </pre>
     *
     * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
     */
    public Builder addBindings(int index, com.google.iam.v1.Binding.Builder builderForValue) {
      copyOnWrite();
      instance.addBindings(index, builderForValue.build());
      return this;
    }
    /**
     *
     *
     * <pre>
     * Associates a list of `members`, or principals, with a `role`. Optionally,
     * may specify a `condition` that determines how and when the `bindings` are
     * applied. Each of the `bindings` must contain at least one principal.
     *
     * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
     * of these principals can be Google groups. Each occurrence of a principal
     * counts towards these limits. For example, if the `bindings` grant 50
     * different roles to `user:alice&#64;example.com`, and not to any other
     * principal, then you can add another 1,450 principals to the `bindings` in
     * the `Policy`.
     * </pre>
     *
     * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
     */
    public Builder addAllBindings(java.lang.Iterable<? extends com.google.iam.v1.Binding> values) {
      copyOnWrite();
      instance.addAllBindings(values);
      return this;
    }
    /**
     *
     *
     * <pre>
     * Associates a list of `members`, or principals, with a `role`. Optionally,
     * may specify a `condition` that determines how and when the `bindings` are
     * applied. Each of the `bindings` must contain at least one principal.
     *
     * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
     * of these principals can be Google groups. Each occurrence of a principal
     * counts towards these limits. For example, if the `bindings` grant 50
     * different roles to `user:alice&#64;example.com`, and not to any other
     * principal, then you can add another 1,450 principals to the `bindings` in
     * the `Policy`.
     * </pre>
     *
     * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
     */
    public Builder clearBindings() {
      copyOnWrite();
      instance.clearBindings();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Associates a list of `members`, or principals, with a `role`. Optionally,
     * may specify a `condition` that determines how and when the `bindings` are
     * applied. Each of the `bindings` must contain at least one principal.
     *
     * The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
     * of these principals can be Google groups. Each occurrence of a principal
     * counts towards these limits. For example, if the `bindings` grant 50
     * different roles to `user:alice&#64;example.com`, and not to any other
     * principal, then you can add another 1,450 principals to the `bindings` in
     * the `Policy`.
     * </pre>
     *
     * <code>repeated .google.iam.v1.Binding bindings = 4;</code>
     */
    public Builder removeBindings(int index) {
      copyOnWrite();
      instance.removeBindings(index);
      return this;
    }

    /**
     *
     *
     * <pre>
     * Specifies cloud audit logging configuration for this policy.
     * </pre>
     *
     * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
     */
    @java.lang.Override
    public java.util.List<com.google.iam.v1.AuditConfig> getAuditConfigsList() {
      return java.util.Collections.unmodifiableList(instance.getAuditConfigsList());
    }
    /**
     *
     *
     * <pre>
     * Specifies cloud audit logging configuration for this policy.
     * </pre>
     *
     * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
     */
    @java.lang.Override
    public int getAuditConfigsCount() {
      return instance.getAuditConfigsCount();
    }
    /**
     *
     *
     * <pre>
     * Specifies cloud audit logging configuration for this policy.
     * </pre>
     *
     * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
     */

    @java.lang.Override
    public com.google.iam.v1.AuditConfig getAuditConfigs(int index) {
      return instance.getAuditConfigs(index);
    }
    /**
     *
     *
     * <pre>
     * Specifies cloud audit logging configuration for this policy.
     * </pre>
     *
     * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
     */
    public Builder setAuditConfigs(int index, com.google.iam.v1.AuditConfig value) {
      copyOnWrite();
      instance.setAuditConfigs(index, value);
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies cloud audit logging configuration for this policy.
     * </pre>
     *
     * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
     */
    public Builder setAuditConfigs(
        int index, com.google.iam.v1.AuditConfig.Builder builderForValue) {
      copyOnWrite();
      instance.setAuditConfigs(index, builderForValue.build());
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies cloud audit logging configuration for this policy.
     * </pre>
     *
     * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
     */
    public Builder addAuditConfigs(com.google.iam.v1.AuditConfig value) {
      copyOnWrite();
      instance.addAuditConfigs(value);
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies cloud audit logging configuration for this policy.
     * </pre>
     *
     * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
     */
    public Builder addAuditConfigs(int index, com.google.iam.v1.AuditConfig value) {
      copyOnWrite();
      instance.addAuditConfigs(index, value);
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies cloud audit logging configuration for this policy.
     * </pre>
     *
     * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
     */
    public Builder addAuditConfigs(com.google.iam.v1.AuditConfig.Builder builderForValue) {
      copyOnWrite();
      instance.addAuditConfigs(builderForValue.build());
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies cloud audit logging configuration for this policy.
     * </pre>
     *
     * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
     */
    public Builder addAuditConfigs(
        int index, com.google.iam.v1.AuditConfig.Builder builderForValue) {
      copyOnWrite();
      instance.addAuditConfigs(index, builderForValue.build());
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies cloud audit logging configuration for this policy.
     * </pre>
     *
     * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
     */
    public Builder addAllAuditConfigs(
        java.lang.Iterable<? extends com.google.iam.v1.AuditConfig> values) {
      copyOnWrite();
      instance.addAllAuditConfigs(values);
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies cloud audit logging configuration for this policy.
     * </pre>
     *
     * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
     */
    public Builder clearAuditConfigs() {
      copyOnWrite();
      instance.clearAuditConfigs();
      return this;
    }
    /**
     *
     *
     * <pre>
     * Specifies cloud audit logging configuration for this policy.
     * </pre>
     *
     * <code>repeated .google.iam.v1.AuditConfig audit_configs = 6;</code>
     */
    public Builder removeAuditConfigs(int index) {
      copyOnWrite();
      instance.removeAuditConfigs(index);
      return this;
    }

    /**
     *
     *
     * <pre>
     * `etag` is used for optimistic concurrency control as a way to help
     * prevent simultaneous updates of a policy from overwriting each other.
     * It is strongly suggested that systems make use of the `etag` in the
     * read-modify-write cycle to perform policy updates in order to avoid race
     * conditions: An `etag` is returned in the response to `getIamPolicy`, and
     * systems are expected to put that etag in the request to `setIamPolicy` to
     * ensure that their change will be applied to the same version of the policy.
     *
     * **Important:** If you use IAM Conditions, you must include the `etag` field
     * whenever you call `setIamPolicy`. If you omit this field, then IAM allows
     * you to overwrite a version `3` policy with a version `1` policy, and all of
     * the conditions in the version `3` policy are lost.
     * </pre>
     *
     * <code>bytes etag = 3;</code>
     *
     * @return The etag.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString getEtag() {
      return instance.getEtag();
    }
    /**
     *
     *
     * <pre>
     * `etag` is used for optimistic concurrency control as a way to help
     * prevent simultaneous updates of a policy from overwriting each other.
     * It is strongly suggested that systems make use of the `etag` in the
     * read-modify-write cycle to perform policy updates in order to avoid race
     * conditions: An `etag` is returned in the response to `getIamPolicy`, and
     * systems are expected to put that etag in the request to `setIamPolicy` to
     * ensure that their change will be applied to the same version of the policy.
     *
     * **Important:** If you use IAM Conditions, you must include the `etag` field
     * whenever you call `setIamPolicy`. If you omit this field, then IAM allows
     * you to overwrite a version `3` policy with a version `1` policy, and all of
     * the conditions in the version `3` policy are lost.
     * </pre>
     *
     * <code>bytes etag = 3;</code>
     *
     * @param value The etag to set.
     * @return This builder for chaining.
     */
    public Builder setEtag(com.google.protobuf.ByteString value) {
      copyOnWrite();
      instance.setEtag(value);
      return this;
    }
    /**
     *
     *
     * <pre>
     * `etag` is used for optimistic concurrency control as a way to help
     * prevent simultaneous updates of a policy from overwriting each other.
     * It is strongly suggested that systems make use of the `etag` in the
     * read-modify-write cycle to perform policy updates in order to avoid race
     * conditions: An `etag` is returned in the response to `getIamPolicy`, and
     * systems are expected to put that etag in the request to `setIamPolicy` to
     * ensure that their change will be applied to the same version of the policy.
     *
     * **Important:** If you use IAM Conditions, you must include the `etag` field
     * whenever you call `setIamPolicy`. If you omit this field, then IAM allows
     * you to overwrite a version `3` policy with a version `1` policy, and all of
     * the conditions in the version `3` policy are lost.
     * </pre>
     *
     * <code>bytes etag = 3;</code>
     *
     * @return This builder for chaining.
     */
    public Builder clearEtag() {
      copyOnWrite();
      instance.clearEtag();
      return this;
    }

    // @@protoc_insertion_point(builder_scope:google.iam.v1.Policy)
  }

  @java.lang.Override
  @java.lang.SuppressWarnings({"unchecked", "fallthrough"})
  protected final java.lang.Object dynamicMethod(
      com.google.protobuf.GeneratedMessageLite.MethodToInvoke method,
      java.lang.Object arg0,
      java.lang.Object arg1) {
    switch (method) {
      case NEW_MUTABLE_INSTANCE:
        {
          return new com.google.iam.v1.Policy();
        }
      case NEW_BUILDER:
        {
          return new Builder();
        }
      case BUILD_MESSAGE_INFO:
        {
          java.lang.Object[] objects =
              new java.lang.Object[] {
                "version_",
                "etag_",
                "bindings_",
                com.google.iam.v1.Binding.class,
                "auditConfigs_",
                com.google.iam.v1.AuditConfig.class,
              };
          java.lang.String info =
              "\u0000\u0004\u0000\u0000\u0001\u0006\u0004\u0000\u0002\u0000\u0001\u0004\u0003\n"
                  + "\u0004\u001b\u0006\u001b";
          return newMessageInfo(DEFAULT_INSTANCE, info, objects);
        }
        // fall through
      case GET_DEFAULT_INSTANCE:
        {
          return DEFAULT_INSTANCE;
        }
      case GET_PARSER:
        {
          com.google.protobuf.Parser<com.google.iam.v1.Policy> parser = PARSER;
          if (parser == null) {
            synchronized (com.google.iam.v1.Policy.class) {
              parser = PARSER;
              if (parser == null) {
                parser = new DefaultInstanceBasedParser<com.google.iam.v1.Policy>(DEFAULT_INSTANCE);
                PARSER = parser;
              }
            }
          }
          return parser;
        }
      case GET_MEMOIZED_IS_INITIALIZED:
        {
          return (byte) 1;
        }
      case SET_MEMOIZED_IS_INITIALIZED:
        {
          return null;
        }
    }
    throw new UnsupportedOperationException();
  }

  // @@protoc_insertion_point(class_scope:google.iam.v1.Policy)
  private static final com.google.iam.v1.Policy DEFAULT_INSTANCE;

  static {
    Policy defaultInstance = new Policy();
    // New instances are implicitly immutable so no need to make
    // immutable.
    DEFAULT_INSTANCE = defaultInstance;
    com.google.protobuf.GeneratedMessageLite.registerDefaultInstance(Policy.class, defaultInstance);
  }

  public static com.google.iam.v1.Policy getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static volatile com.google.protobuf.Parser<Policy> PARSER;

  public static com.google.protobuf.Parser<Policy> parser() {
    return DEFAULT_INSTANCE.getParserForType();
  }
}
